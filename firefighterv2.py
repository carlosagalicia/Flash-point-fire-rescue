# -*- coding: utf-8 -*-
"""FireFighter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fyoRWBlyYnEKlapI8oj7ejYHaoYc9Y0Q
"""

# Commented out IPython magic to ensure Python compatibility.
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model

# Debido a que necesitamos que existe un solo agente por celda, elegimos ''SingleGrid''.
from mesa.space import SingleGrid, MultiGrid

# Con ''RandomActivation'', hacemos que todos los agentes se activen ''al mismo tiempo''.
from mesa.time import RandomActivation

# Haremos uso de ''batch_run'' para ejecutar varias simulaciones
from mesa.batchrunner import batch_run

# seaborn lo usaremos desplegar una gráficas más ''vistosas'' de
# nuestro modelo
import seaborn as sns

from functools import partial

# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime
import random

import heapq
from typing import List, Tuple, Dict

import json

class FireFighter(Agent):
    def __init__(self, id, model, x, y):
        # Call the parent class constructor to initialize id and model
        super().__init__(id, model)

        # Set initial energy level for the firefighter
        self.energy = 4

        # Boolean indicating if the firefighter is currently carrying something
        self.carrying = False

        # List to store the path the firefighter will take
        self.path = []

        # List to store moves required to reach the goal
        self.movesToGoal = []

        # Store the previous position of the firefighter
        self.previousPos = self.pos

        # Placeholder for the next position of the firefighter
        self.nextPos = None

        # Store the nearest Point of Interest (POI)
        self.nearestPOI = None

        # Store the nearest entry point for the firefighter
        self.nearestEntrypoint = None

        # Boolean indicating if the firefighter is blocked and cannot move
        self.isBlocked = False

        # Boolean indicating if the firefighter can advance towards its goal
        self.canAdvance = True

        # Cost of moving to the next position
        self.moveCost = 1

        # Index for tracking the current move in a sequence of moves
        self.move_index = 1

        # Set the initial position of the firefighter as a tuple (x, y)
        self.initialPos = (x, y)


    def calculateNearest(self):
        # Calculate the nearest Point of Interest (POI) to the firefighter's current tile
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]

        # If not carrying anything and there are available POIs, calculate the nearest POI
        if self.carrying == False and len(self.model.POIsPositions) > 0:
            distances = {poi: abs(poi[0] - current_tile.pos[0]) + abs(poi[1]-current_tile.pos[1]) for poi in self.model.POIsPositions}
            # Find the nearest POI based on calculated distances
            self.nearestPOI = min(distances, key=distances.get)

        # If carrying something, calculate the nearest entry point
        elif self.carrying == True:
            distances = {entrypoint: abs(entrypoint[0] - current_tile.pos[0]) + abs(entrypoint[1]-current_tile.pos[1]) for entrypoint in self.model.entryPoints}
            # Find the nearest entry point based on calculated distances
            self.nearestEntrypoint = min(distances, key=distances.get)


    def dijkstraToNearest(self, graph: Dict[Tuple[int, int], Dict[Tuple[int, int], int]],
                            start: Tuple[int, int],
                            poi: Tuple[int, int]) -> Tuple[List[Tuple[int, int]], int,]:
        # Initialize an empty list to store the moves to the goal
        self.movesToGoal = []

        # Initialize an empty list to store the path taken to reach the POI
        path = []

        # Create a dictionary to hold the shortest distance to each node, initialized to infinity
        distances = {node: float('infinity') for node in graph}

        # Set the distance to the starting node to 0
        distances[start] = 0

        # Create a priority queue initialized with the starting node
        pq = [(0, start)]

        # Dictionary to keep track of the previous node for each node
        previous = {}

        # While there are nodes in the priority queue
        while pq:
            # Get the node with the smallest distance
            current_distance, current_node = heapq.heappop(pq)

            # If the current node is the POI, reconstruct the path
            if current_node == poi:
                while current_node in previous:
                    path.append(current_node)  # Add the current node to the path
                    current_node = previous[current_node]  # Move to the previous node
                path.append(start)  # Add the starting node to the path
                path = list(reversed(path))  # Reverse the path to get the correct order

                break  # Exit the loop once the POI is reached

            # If the current distance is greater than the recorded distance, skip processing
            if current_distance > distances[current_node]:
                continue

            # Check each neighbor of the current node
            for neighbor, weight in graph[current_node].items():
                distance = current_distance + weight  # Calculate the distance to the neighbor
                # If the calculated distance is less than the recorded distance, update it
                if distance < distances[neighbor]:
                    distances[neighbor] = distance  # Update the shortest distance
                    previous[neighbor] = current_node  # Update the previous node
                    heapq.heappush(pq, (distance, neighbor))  # Add the neighbor to the priority queue

        # Store the computed path in movesToGoal
        self.movesToGoal = path

    def move(self, next_position):
        # Current position of the agent
        current_position = self.pos

        # Obtain the current Tile
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([current_position]) if isinstance(obj, Tile)][0]

        # Remove the firefighter from the current tile's list of firefighters
        current_tile.hasFireFighter.remove(self)

        # Obtain the next Tile
        next_tile = [obj for obj in self.model.grid.get_cell_list_contents([next_position]) if isinstance(obj, Tile)][0]

        # Add the firefighter to the next tile's list of firefighters
        next_tile.hasFireFighter.append(self)

        # Move the agent to the next position on the grid
        self.model.grid.move_agent(self, next_position)

        # Calculate the change in position (dx and dy)
        dx = next_position[0] - current_position[0]
        dy = next_position[1] - current_position[1]

        # Append the affected tile information to the model
        self.model.appendAffectedTile(current_tile, "move", dx, dy)

        # Reduce energy based on whether the firefighter is carrying a victim or not
        if self.carrying:
            self.energy -= 2  # Costs more energy if carrying a victim
        else:
            self.energy -= 1  # Standard movement cost

        # If there is a POI (Point of Interest) at the new position, reveal it
        if next_tile.hasPOI == True:
            next_tile.hasPOI = False  # Mark the POI as revealed
            self.model.numOfPOIs -= 1  # Decrease the count of POIs

            # If the POI type is a victim, increase the number of victims
            if next_tile.poi == "v":
                next_tile.numberOfVictims += 1  # Increment the number of victims
                self.carryVictim()  # Call function to carry the victim

            next_tile.poi = None  # Clear the POI information
            self.model.currentPOIS -= 1  # Decrease the count of current POIs

        # Append the affected tile information for the next tile
        self.model.appendAffectedTile(next_tile, "stand", dx, dy)

        # Clear the list of affected tiles for the next action
        self.model.affectedTiles = []


    def step(self):
        # Reset move index to the first move
        self.move_index = 1

        # Replenish Points of Interest (POIs) in the model
        self.model.replenishPOIs()

        # Determine the nearest target based on whether the firefighter is carrying a victim or not
        if self.carrying == False:
            self.calculateNearest()  # Calculate the nearest POI
            self.dijkstraToNearest(self.model.graph, self.pos, self.nearestPOI)  # Find the path to the nearest POI
            goalPos = self.nearestPOI  # Set goal position to the nearest POI
        else:
            self.calculateNearest()  # Calculate the nearest entry point
            self.dijkstraToNearest(self.model.graph, self.pos, self.nearestEntrypoint)  # Find the path to the nearest entry point
            goalPos = self.nearestEntrypoint  # Set goal position to the nearest entry point

        # Continue moving as long as there is energy and the move index is within the bounds of movesToGoal
        while self.energy > 0 and self.move_index < len(self.movesToGoal) and self.canAdvance == True:
            # If at the nearest POI, find the nearest entry point
            if self.pos == self.nearestPOI:
                self.move_index = 1  # Reset move index
                self.calculateNearest()  # Calculate the nearest entry point
                self.dijkstraToNearest(self.model.graph, self.pos, self.nearestEntrypoint)  # Find the path to the nearest entry point
                goalPos = self.nearestEntrypoint  # Update goal position to the nearest entry point
            # If at the nearest entry point, drop the victim and find the nearest POI
            elif self.pos == self.nearestEntrypoint:
                self.move_index = 1  # Reset move index
                self.dropVictim()  # Drop the victim at the entry point
                self.calculateNearest()  # Calculate the nearest POI
                self.dijkstraToNearest(self.model.graph, self.pos, self.nearestPOI)  # Find the path to the nearest POI
                goalPos = self.nearestPOI  # Update goal position to the nearest POI

            # Get the next move from the list of moves to the goal
            move = self.movesToGoal[self.move_index]

            # Obtain the current and next tiles
            current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]
            next_tile = [obj for obj in self.model.grid.get_cell_list_contents([move]) if isinstance(obj, Tile)][0]

            # Evaluate if there is any blockage between the current position and the next position
            match self.model.graph[self.pos][move]:
                case 1:
                    self.isBlocked = False  # No blockage
                case 2:
                    self.isBlocked = True  # Blocked by a door
                    blocker = "Door"
                case 3:
                    self.isBlocked = True  # Blocked by a damaged wall
                    blocker = "Damaged Wall"
                case 5:
                    self.isBlocked = True  # Blocked by a wall
                    blocker = "Wall"

            # If not blocked and can advance, proceed with movement or action
            if self.isBlocked == False and self.canAdvance:
                if next_tile.fireStatus == 2:  # If the next tile is on fire
                    if self.energy >= 2:  # Check if there is enough energy to extinguish
                        self.extinguish(move)  # Extinguish the fire at the next position
                    else:
                        self.canAdvance = False  # Cannot advance due to insufficient energy
                else:
                    if self.energy >= self.moveCost:  # Check if there is enough energy to move
                        self.move(move)  # Move to the next position
                        self.move_index += 1  # Increment move index
                    else:
                        self.canAdvance = False  # Cannot advance due to insufficient energy
            # If blocked, handle the type of blockage
            elif self.isBlocked == True and self.canAdvance:
                match blocker:
                    case "Door":
                        if self.energy >= 1:  # Check energy to manipulate the door
                            self.manipulateDoor(True, move)  # Manipulate door to pass through
                            self.model.graph[self.pos][move] = 1  # Update graph to reflect movement
                            self.model.graph[move][self.pos] = 1  # Update reverse graph
                        else:
                            self.canAdvance = False  # Cannot advance due to insufficient energy
                    case "Damaged Wall":
                        if self.energy >= 2:  # Check energy to damage the wall
                            self.damage(False, move)  # Damage the wall to pass through
                            self.model.graph[self.pos][move] = 1  # Update graph to reflect movement
                            self.model.graph[move][self.pos] = 1  # Update reverse graph
                        else:
                            self.canAdvance = False  # Cannot advance due to insufficient energy
                    case "Wall":
                        if self.energy >= 4:  # Check energy to damage the wall
                            self.damage(True, move)  # Damage the wall to pass through
                            self.model.graph[self.pos][move] = 1  # Update graph to reflect movement
                            self.model.graph[move][self.pos] = 1  # Update reverse graph
                        else:
                            self.canAdvance = False  # Cannot advance due to insufficient energy

            # If at the nearest POI, find the nearest entry point
            if self.pos == self.nearestPOI:
                self.move_index = 1  # Reset move index
                self.calculateNearest()  # Calculate the nearest entry point
                self.dijkstraToNearest(self.model.graph, self.pos, self.nearestEntrypoint)  # Find the path to the nearest entry point
                goalPos = self.nearestEntrypoint  # Update goal position to the nearest entry point
            # If at the nearest entry point, drop the victim and find the nearest POI
            elif self.pos == self.nearestEntrypoint:
                self.move_index = 1  # Reset move index
                self.dropVictim()  # Drop the victim at the entry point
                self.calculateNearest()  # Calculate the nearest POI
                self.dijkstraToNearest(self.model.graph, self.pos, self.nearestPOI)  # Find the path to the nearest POI
                goalPos = self.nearestPOI  # Update goal position to the nearest POI

        # If at the nearest POI, reset move index
        if self.pos == self.nearestPOI:
            self.move_index = 1

        # If at the nearest entry point, reset move index and drop the victim
        if self.pos == self.nearestEntrypoint:
            self.move_index = 1
            self.dropVictim()  # Drop the victim at the entry point

        # If energy is depleted, reset move index
        if self.energy <= 0:
            self.move_index = 1

        # Reset the energy level for the next turn
        self.energy = 4 + self.energy  # Restore energy
        if self.energy > 8:  # Cap the energy at 8
            self.energy = 8

        self.canAdvance = True  # Reset the ability to advance
        self.model.throwDice()  # Execute dice throw for any game mechanics

        # Update the current agents dictionary with the agent's current state
        self.model.currentAgentsDictionary[self.unique_id] = self.model.allTiles

        # Clear the list of all tiles for the next turn
        self.model.allTiles = []

    def manipulateDoor(self, status, next_pos): # True para cerrar puerta, false para abrirla
        # Get the current tile where the agent is located
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]

        # Get the tile in the direction of the next position
        tile2 = [obj for obj in self.model.grid.get_cell_list_contents([next_pos]) if isinstance(obj, Tile)][0]

        # Set the door status (open/closed) for both the current tile and the next tile
        current_tile.wall.isOpen = status
        tile2.wall.isOpen = status

        # Calculate the change in position
        dx = next_pos[0] - self.pos[0]
        dy = next_pos[1] - self.pos[1]

        # Decrease energy for the action of manipulating the door
        self.energy -= 1

        # Append the affected tiles to the model for tracking
        self.model.appendAffectedTile(current_tile,"stand", dx, dy)
        self.model.appendAffectedTile(tile2,"stand", dx, dy)

        # Clear the list of affected tiles for the next operation
        self.model.affectedTiles = []

    def extinguish(self, move):
        # Get the current tile where the agent is located
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]

        # Get the tile in the direction of the move
        next_tile = [obj for obj in self.model.grid.get_cell_list_contents([move]) if isinstance(obj, Tile)][0]

        # Set the fire status of the next tile to 0 (extinguished)
        next_tile.fireStatus = 0

        # Decrease energy for the action of extinguishing the fire
        self.energy -= 2

        # Calculate the change in position
        dx = move[0] - self.pos[0]
        dy = move[1] - self.pos[1]

        # Append the affected tile to the model for tracking
        self.model.appendAffectedTile(next_tile,"stand", dx, dy)


    def damage(self, demolish, next_pos):
        # Get the current tile where the agent is located
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]

        # Calculate the change in position
        dx = next_pos[0] - self.pos[0]
        dy = next_pos[1] - self.pos[1]

        # Get the tile in the direction of the next position
        other_tile = [obj for obj in self.model.grid.get_cell_list_contents([(self.pos[0]+dx, self.pos[1]+dy)]) if isinstance(obj, Tile)][0]

        if demolish:
            # Decrease energy for the action of demolishing
            self.energy -= 4
            self.model.damageCounter += 2

            # Handle the case for different directions of demolition
            if dx == -1:  # Moving left
                other_tile.wall.bottomHealth = 0
                other_tile.wall.bottom = 0
                current_tile.wall.topHealth = 0
                current_tile.wall.top = 0
            elif dy == -1:  # Moving up
                other_tile.wall.rightHealth = 0
                other_tile.wall.right = 0
                current_tile.wall.leftHealth = 0
                current_tile.wall.left = 0
            elif dx == 1:  # Moving right
                other_tile.wall.topHealth = 0
                other_tile.wall.top = 0
                current_tile.wall.bottomHealth = 0
                current_tile.wall.bottom = 0
            elif dy == 1:  # Moving down
                other_tile.wall.leftHealth = 0
                other_tile.wall.left = 0
                current_tile.wall.rightHealth = 0
                current_tile.wall.right = 0
        else:
            # Decrease energy for the action of damaging
            self.energy -= 2
            self.model.damageCounter += 1

            # Handle the case for different directions of damage
            if dx == -1:  # Moving left
                other_tile.wall.bottomHealth -= 2
                if other_tile.wall.bottomHealth <= 0:  # Check if the wall is destroyed
                    other_tile.wall.bottom = 0
                current_tile.wall.topHealth -= 2
                if current_tile.wall.topHealth <= 0:  # Check if the wall is destroyed
                    current_tile.wall.top = 0
            elif dy == -1:  # Moving up
                other_tile.wall.rightHealth -= 2
                if other_tile.wall.rightHealth <= 0:  # Check if the wall is destroyed
                    other_tile.wall.right = 0
                current_tile.wall.leftHealth -= 2
                if current_tile.wall.leftHealth <= 0:  # Check if the wall is destroyed
                    current_tile.wall.left = 0
            elif dx == 1:  # Moving right
                other_tile.wall.topHealth -= 2
                if other_tile.wall.topHealth <= 0:  # Check if the wall is destroyed
                    other_tile.wall.top = 0
                current_tile.wall.bottomHealth -= 2
                if current_tile.wall.bottomHealth <= 0:  # Check if the wall is destroyed
                    current_tile.wall.bottom = 0
            elif dy == 1:  # Moving down
                other_tile.wall.leftHealth -= 2
                if other_tile.wall.leftHealth <= 0:  # Check if the wall is destroyed
                    other_tile.wall.left = 0
                current_tile.wall.rightHealth -= 2
                if current_tile.wall.rightHealth <= 0:  # Check if the wall is destroyed
                    current_tile.wall.right = 0

        # Append the affected tiles to the model for tracking
        self.model.appendAffectedTile(current_tile,"stand", dx, dy)
        self.model.appendAffectedTile(other_tile,"stand", dx, dy)

        # Clear the list of affected tiles for the next operation
        self.model.affectedTiles = []


    def carryVictim(self):
        # Get the current tile where the agent is located
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]

        # Check if there are victims to carry on the current tile
        if current_tile.numberOfVictims > 0:
            # Set the carrying status to True
            self.carrying = True
            # Decrease the number of victims on the current tile
            current_tile.numberOfVictims -= 1
            # Set the movement cost to 2 while carrying a victim
            self.moveCost = 2


    def dropVictim(self):
        # Get the current tile where the agent is located
        current_tile = [obj for obj in self.model.grid.get_cell_list_contents([self.pos]) if isinstance(obj, Tile)][0]

        # Set the carrying status to False
        self.carrying = False
        # Reset the movement cost to 1 after dropping the victim
        self.moveCost = 1
        # Increment the count of saved victims in the model
        self.model.savedVictims += 1

        # Append the current tile as affected for the action of dropping the victim
        self.model.appendAffectedTile(current_tile,"stand", 0, 0)

class Wall():
    def __init__(self, id, top, left, bottom, right, isDoor=0, isOpen=False):
        # Assign a unique identifier to the wall
        self.unique_id = id

        # Set the wall properties for each side (top, bottom, left, right)
        self.top = top
        self.bottom = bottom
        self.left = left
        self.right = right

        # Specify if the wall has a door (0 indicates no door)
        self.isDoor = isDoor

        # Boolean indicating if the door is currently open
        self.isOpen = isOpen

        # Initialize the health of the walls (4 times the wall presence value)
        self.topHealth = 4 * top
        self.bottomHealth = 4 * bottom
        self.leftHealth = 4 * left
        self.rightHealth = 4 * right

        # Adjust wall properties if a door is present
        if self.isDoor != 0:
            if self.isDoor == 1:  # Door at the top
                self.top = 2  # Change top wall to represent a door
                self.topHealth = 2  # Set health for the door
            if self.isDoor == 2:  # Door on the left
                self.left = 2  # Change left wall to represent a door
                self.leftHealth = 2  # Set health for the door
            if self.isDoor == 3:  # Door at the bottom
                self.bottom = 2  # Change bottom wall to represent a door
                self.bottomHealth = 2  # Set health for the door
            if self.isDoor == 4:  # Door on the right
                self.right = 2  # Change right wall to represent a door
                self.rightHealth = 2  # Set health for the door

class Tile():
    def __init__(self, id, top, left, bottom, right, isDoor, isOpen=False):
        # Assign a unique identifier to the tile
        self.unique_id = id

        # Initialize the position of the tile (default is None)
        self.pos = None

        # Create a Wall object for the tile with the provided wall properties
        self.wall = Wall(id, top, left, bottom, right, isDoor, isOpen)

        # Initialize the fire status of the tile (0 indicates no fire)
        self.fireStatus = 0

        # Boolean indicating if the tile has a Point of Interest (POI)
        self.hasPOI = False

        # Counter for the number of victims present in the tile
        self.numberOfVictims = 0

        # List to hold firefighters assigned to the tile
        self.hasFireFighter = []

        # Reference to a POI (Point of Interest) associated with the tile
        self.poi = None

class FireRescueModel(Model):
    def __init__(self, firefighters, width, height, entrypoints, walls, doors, fires, pois):
        super().__init__()  # Initialize the parent class Model
        self.grid = MultiGrid(width, height, torus=False)  # Create a grid for the model
        self.schedule = RandomActivation(self)  # Create a schedule for agents

        self.steps = 0  # Counter for the number of steps taken in the simulation
        self.entryPoints = entrypoints  # Store the entry points for the firefighters
        self.damageCounter = 0  # Counter for tracking damage
        self.numOfPOIs = 15  # Total number of Points of Interest
        self.truePOIs = 10  # Number of true Points of Interest
        self.falsePOIs = 5  # Number of false Points of Interest
        self.currentPOIS = 0  # Counter for currently active Points of Interest
        self.savedVictims = 0  # Counter for saved victims
        self.deadVictims = 0  # Counter for dead victims
        self.running = True  # Flag to indicate if the simulation is running
        self.POIsPositions = []  # List to store the positions of Points of Interest
        self.dictionaryList = []  # List to store dictionaries related to the simulation
        self.tilesMatrix = {}  # Dictionary to hold the state of tiles
        self.initialDictionary = {}  # Dictionary for initial conditions
        self.currentAgentsDictionary = {}  # Dictionary for the current agents
        self.walls = walls  # Store wall configurations
        self.doors = doors  # Store door configurations
        self.win = 0  # Counter for winning conditions
        self.demolishedLose = 0  # Counter for losses due to demolition
        self.deadVictimLose = 0  # Counter for losses due to dead victims
        self.affectedTiles = []  # List to store affected tiles during the simulation
        self.allTiles = []  # List to store all tiles

        self.graph = self.generateGraph(walls)  # Generate a graph representation of walls
        self.graph = self.addDoorArches(self.graph, doors, cost=2)  # Add door arches to the graph with a cost

        # Place the tiles (quadrants) in the grid
        for j, row in enumerate(walls):
            for i, wall in enumerate(row):
                entryPointTile = False  # Flag to check if the tile is an entry point
                for point in entrypoints:
                    if point[0] == j+1 and point[1] == i+1:  # Check if the placed quadrant has an entry point
                        if point[0] == 1:  # Upper entry point
                            tile = Tile((j+1,i+1), wall[0], wall[1], wall[2], wall[3], 1, True)
                            entryPointTile = True
                        elif point[1] == 1:  # Left entry point
                            tile = Tile((j+1,i+1), wall[0], wall[1], wall[2], wall[3], 2, True)
                            entryPointTile = True
                        elif point[0] == 6:  # Lower entry point
                            tile = Tile((j+1,i+1), wall[0], wall[1], wall[2], wall[3], 3, True)
                            entryPointTile = True
                        elif point[1] == 8:  # Right entry point
                            tile = Tile((j+1,i+1), wall[0], wall[1], wall[2], wall[3], 4, True)
                            entryPointTile = True

                if not entryPointTile:
                    tile = Tile((j+1,i+1), wall[0], wall[1], wall[2], wall[3], 0)  # Create a normal tile if no entry point

                self.grid.place_agent(tile, (j+1, i+1))  # Place the tile in the grid

        # Place fires in the grid
        for fire in fires:
            tile = [obj for obj in self.grid.get_cell_list_contents([(fire[0], fire[1])]) if isinstance(obj, Tile)][0]
            tile.fireStatus = 2  # Set the fire status of the tile

        # Place doors in the grid
        for door in doors:
            x1, y1, x2, y2 = door

            tile1 = [obj for obj in self.grid.get_cell_list_contents([(x1, y1)]) if isinstance(obj, Tile)][0]
            tile2 = [obj for obj in self.grid.get_cell_list_contents([(x2, y2)]) if isinstance(obj, Tile)][0]

            dx = abs(x1 - x2)  # Calculate horizontal distance between door tiles
            dy = abs(y1 - y2)  # Calculate vertical distance between door tiles

            if dx == 0 and dy == 1:
                # Tiles are next to each other horizontally
                if y1 < y2:
                    tile1.wall.right = 2  # Set right wall of tile1 as a door
                    tile2.wall.left = 2  # Set left wall of tile2 as a door
                    tile1.wall.isDoor = 4  # Mark tile1 wall as a door
                    tile2.wall.isDoor = 2  # Mark tile2 wall as a door
                    tile1.wall.rightHealth = 2  # Set health of right wall
                    tile2.wall.leftHealth = 2  # Set health of left wall
                else:
                    tile1.wall.left = 2  # Set left wall of tile1 as a door
                    tile2.wall.right = 2  # Set right wall of tile2 as a door
                    tile1.wall.isDoor = 2  # Mark tile1 wall as a door
                    tile2.wall.isDoor = 4  # Mark tile2 wall as a door
                    tile1.wall.leftHealth = 2  # Set health of left wall
                    tile2.wall.rightHealth = 2  # Set health of right wall

            elif dy == 0 and dx == 1:
                # Tiles are one above the other vertically
                if x1 < x2:
                    tile1.wall.bottom = 2  # Set bottom wall of tile1 as a door
                    tile2.wall.top = 2  # Set top wall of tile2 as a door
                    tile1.wall.isDoor = 3  # Mark tile1 wall as a door
                    tile2.wall.isDoor = 1  # Mark tile2 wall as a door
                    tile1.wall.bottomHealth = 2  # Set health of bottom wall
                    tile2.wall.topHealth = 2  # Set health of top wall
                else:
                    tile1.wall.top = 2  # Set top wall of tile1 as a door
                    tile2.wall.bottom = 2  # Set bottom wall of tile2 as a door
                    tile1.wall.isDoor = 1  # Mark tile1 wall as a door
                    tile2.wall.isDoor = 3  # Mark tile2 wall as a door
                    tile1.wall.topHealth = 2  # Set health of top wall
                    tile2.wall.bottomHealth = 2  # Set health of bottom wall

        # Place firefighters outside the house at entry points
        for i in range(firefighters):
            x, y = random.choice(entryPoints)  # Randomly select an entry point
            tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]

            firefighter = FireFighter(i, self, x, y)  # Create a firefighter agent
            tile.hasFireFighter.append(firefighter)  # Add the firefighter to the tile
            self.grid.place_agent(firefighter, (x, y))  # Place the firefighter in the grid
            self.schedule.add(firefighter)  # Add the firefighter to the schedule

        # Place Points of Interest (POIs) in the grid
        for poi in pois:
            x, y, victim = poi  # Unpack the POI data
            tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]
            self.spawnPOI(x, y, tile, victim)  # Spawn the POI in the grid
            self.affectedTiles = []  # Reset affected tiles list

        # Initialize the tilesMatrix with wall states
        for i in range(1, self.grid.width-1):
            for j in range(1, self.grid.height-1):
                tile = [obj for obj in self.grid.get_cell_list_contents([(i, j)]) if isinstance(obj, Tile)][0]
                self.tilesMatrix[(i, j)] = [tile.wall.top, tile.wall.left, tile.wall.bottom, tile.wall.right]  # Store wall states in the matrix


    def appendAffectedTile(self, tile, stateString, dx, dy):
        firefightersIDs = []  # Initialize a list to store the unique IDs of firefighters in the tile
        for firefighter in tile.hasFireFighter:
            firefightersIDs.append(firefighter.unique_id)  # Append each firefighter's unique ID to the list

        # Append the tile's state and relevant information to the affectedTiles list
        self.affectedTiles.append([tile.pos,  # Position of the tile
                                  tile.wall.top,  # State of the top wall
                                  tile.wall.left,  # State of the left wall
                                  tile.wall.bottom,  # State of the bottom wall
                                  tile.wall.right,  # State of the right wall
                                  tile.wall.isOpen,  # Whether the wall is open
                                  tile.wall.topHealth,  # Health of the top wall
                                  tile.wall.leftHealth,  # Health of the left wall
                                  tile.wall.bottomHealth,  # Health of the bottom wall
                                  tile.wall.rightHealth,  # Health of the right wall
                                  tile.fireStatus,  # Fire status of the tile
                                  tile.hasPOI,  # Whether the tile has a Point of Interest
                                  tile.numberOfVictims,  # Number of victims in the tile
                                  firefightersIDs,  # List of firefighter IDs
                                  stateString,  # State string for additional information
                                  dx,  # Change in x position
                                  dy,  # Change in y position
                                    self.damageCounter,  # Damage of the house
                                    tile.poi,  # POI of the house
                                    self.savedVictims,  # Saved victims
                                    self.deadVictims])  # Dead victims

        # Append the same tile's state and relevant information to the allTiles list
        self.allTiles.append([tile.pos,  # Position of the tile
                                  tile.wall.top,  # State of the top wall
                                  tile.wall.left,  # State of the left wall
                                  tile.wall.bottom,  # State of the bottom wall
                                  tile.wall.right,  # State of the right wall
                                  tile.wall.isOpen,  # Whether the wall is open
                                  tile.wall.topHealth,  # Health of the top wall
                                  tile.wall.leftHealth,  # Health of the left wall
                                  tile.wall.bottomHealth,  # Health of the bottom wall
                                  tile.wall.rightHealth,  # Health of the right wall
                                  tile.fireStatus,  # Fire status of the tile
                                  tile.hasPOI,  # Whether the tile has a Point of Interest
                                  tile.numberOfVictims,  # Number of victims in the tile
                                  firefightersIDs,  # List of firefighter IDs
                                  stateString,  # State string for additional information
                                  dx,  # Change in x position
                                  dy,# Change in y position
                                    self.damageCounter,  # Damage of the house
                                    tile.poi,  # POI of the house
                                    self.savedVictims,  # Saved victims
                                    self.deadVictims])  # Dead victims


    def revealPOI(self, current_tile):
        # If the tile with fire has a Point of Interest (POI), reveal it and kill the victim if present
        if current_tile.hasPOI == True:

            current_tile.hasPOI = False  # Mark the POI as revealed
            self.numOfPOIs -= 1  # Decrease the total number of POIs
            self.currentPOIS -= 1  # Decrease the current number of POIs
            if current_tile.poi == "v":  # Check if the POI represents a victim

                current_tile.numberOfVictims -= 1  # Decrease the number of victims in the tile
                self.deadVictims += 1  # Increase the count of dead victims
                current_tile.poi = None  # Remove the POI from the tile


    def spawnPOI(self, x, y, tile, victim):
        # If the POI lands on a firefighter agent...
        # reveal it and decrease the number of POIs
        while len(tile.hasFireFighter) > 0:
            tile.hasPOI = False  # Mark the POI as revealed
            self.numOfPOIs -= 1  # Decrease the total number of POIs
            if victim == "v":  # Check if the victim is present
                tile.numberOfVictims += 1  # Increase the number of victims in the tile

            # Place another POI at a random position
            x = self.random.randint(1, self.grid.width - 2)  # Get a random x coordinate
            y = self.random.randint(1, self.grid.height - 2)  # Get a random y coordinate
            tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]  # Get the tile at the new position

        # If the POI lands on another POI...
        # decrease the number of POIs
        while tile.hasPOI == True:
            # Place another POI at a random position
            x = self.random.randint(1, self.grid.width - 2)  # Get a random x coordinate
            y = self.random.randint(1, self.grid.height - 2)  # Get a random y coordinate
            tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]  # Get the tile at the new position

        self.POIsPositions.append(tile.pos)  # Add the tile's position to the list of POI positions
        # Place the POI
        tile.hasPOI = True  # Mark the tile as having a POI
        tile.poi = victim  # Set the type of POI (victim or not)
        self.currentPOIS += 1  # Increase the current number of POIs
        # Turn off fires or smoke
        if tile.fireStatus != 0:
            tile.fireStatus = 0  # Set fire status to 0 (no fire)

        if victim == "v":  # Check if the POI is a victim
            tile.numberOfVictims += 1  # Increase the number of victims in the tile
            self.truePOIs -= 1  # Decrease the count of true POIs
        else:
            self.falsePOIs -= 1  # Decrease the count of false POIs

        # Print data related to POI
        self.appendAffectedTile(tile, "stand", 0, 0)  # Append affected tile information
        self.affectedTiles = []  # Reset the affected tiles list


    def replenishPOIs(self):
        # While there are less than 3 current POIs and more than 0 total POIs
        while self.currentPOIS < 3 and self.numOfPOIs > 0:
            x = self.random.randint(1, self.grid.width - 2)  # Get a random x coordinate within the grid
            y = self.random.randint(1, self.grid.height - 2)  # Get a random y coordinate within the grid
            tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]  # Get the tile at the random position

            numF = self.falsePOIs  # Get the count of false POIs
            numV = self.truePOIs if self.truePOIs > 0 else 1  # Get the count of true POIs, ensuring it's at least 1
            chance = numF / numV  # Calculate the chance ratio of false to true POIs

            # Randomly choose a number between 1 and 100
            random_number = self.random.randint(1, 100)

            # Determine whether to spawn a false or true POI based on chance
            if (chance > random_number / 100):  # If the chance is greater than the random number
                self.spawnPOI(x, y, tile, "f")  # Spawn a false POI
                numF -= 1  # Decrease the count of false POIs
            else:
                self.spawnPOI(x, y, tile, "v")  # Spawn a true POI
                numV -= 1  # Decrease the count of true POIs

        # Print the location of the tiles with .hasPOI
        self.POIsPositions = []  # Initialize the list to hold positions of POIs
        for i in range(self.grid.width - 1):  # Iterate over the grid width
            for j in range(self.grid.height - 1):  # Iterate over the grid height
                for obj in self.grid.get_cell_list_contents([(i, j)]):  # Check each object in the grid cell
                    if isinstance(obj, Tile) and obj.hasPOI:  # If the object is a Tile and has a POI
                        self.POIsPositions.append(obj.pos)  # Add the position of the tile with POI


    def step(self):
        self.affectedTiles = []  # Reset the list of affected tiles for this step

        self.dictionaryList.append(self.currentAgentsDictionary)  # Add the current agents dictionary to the list
        self.currentAgentsDictionary = {}  # Reset the current agents dictionary
        if self.savedVictims >= 7:  # Check if enough victims have been saved to win
            self.win += 1  # Increase the win count
            print("Game over you won")  # Print win message
            self.running = False  # Set running to False to end the game
            return
        elif self.damageCounter >= 24 or self.deadVictims >= 4:  # Check for losing conditions
            if self.damageCounter >= 24:  # If damage exceeds the limit
                self.demolishedLose += 1  # Increase the demolished loss count
            elif self.deadVictims >= 4:  # If too many victims have died
                self.deadVictimLose += 1  # Increase the dead victim loss count
            print("Game over you lost")  # Print loss message
            self.running = False  # Set running to False to end the game
            return
        else:
            self.schedule.step()  # Proceed to the next step in the schedule
            self.steps += 1  # Increment the step count


    def killFirefighter(self, tile):
        # Check if there are any firefighters on the tile
        if len(tile.hasFireFighter) > 0:
            for firefighter in tile.hasFireFighter:  # Iterate through each firefighter on the tile

                if firefighter.carrying == True:  # Check if the firefighter is carrying a victim
                    firefighter.carrying = False  # Set carrying status to False
                    self.deadVictims += 1  # Increment the count of dead victims
                # Move the firefighter to their initial position
                firefighter.move(firefighter.initialPos)


    def throwDice(self):
        # Generate random x and y coordinates within the grid boundaries
        x = self.random.randint(1, self.grid.width - 2)
        y = self.random.randint(1, self.grid.height - 2)

        # Get the tile at the generated coordinates
        tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]
        if tile.fireStatus == 0:  # Check if the tile has no fire
            tile.fireStatus = 1  # Set the fire status to 1 (indicating fire is starting)
            self.appendAffectedTile(tile, "stand", 0, 0)  # Append the tile as affected

            self.affectedTiles = []  # Reset the affected tiles list
            # Check the tile below
            if x + 1 <= self.grid.width - 2:
                bottom_tile = [obj for obj in self.grid.get_cell_list_contents([(x + 1, y)]) if isinstance(obj, Tile)][0]
                if bottom_tile.fireStatus == 2 and (tile.wall.bottom == 0 or (tile.wall.isDoor == 3 and tile.wall.isOpen)):
                    tile.fireStatus = 2  # Set the fire status to 2 (indicating fire spreading)
                    self.spreadFire(x, y)  # Spread fire from the current tile

             # Check the tile above
            if x - 1 >= 1:
                top_tile = [obj for obj in self.grid.get_cell_list_contents([(x - 1, y)]) if isinstance(obj, Tile)][0]
                if top_tile.fireStatus == 2 and (tile.wall.top == 0 or (tile.wall.isDoor == 1 and tile.wall.isOpen)):
                    tile.fireStatus = 2  # Set the fire status to 2
                    self.spreadFire(x, y)  # Spread fire

            # Check the tile to the left
            if y - 1 >= 1:
                left_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y - 1)]) if isinstance(obj, Tile)][0]
                if left_tile.fireStatus == 2 and (tile.wall.left == 0 or (tile.wall.isDoor == 2 and tile.wall.isOpen)):
                    tile.fireStatus = 2  # Set the fire status to 2
                    self.spreadFire(x, y)  # Spread fire

            # Check the tile to the right
            if y + 1 <= self.grid.height - 2:
                right_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y + 1)]) if isinstance(obj, Tile)][0]
                if right_tile.fireStatus == 2 and (tile.wall.right == 0 or (tile.wall.isDoor == 4 and tile.wall.isOpen)):
                    tile.fireStatus = 2  # Set the fire status to 2
                    self.spreadFire(x, y)  # Spread fire

            # If the tile already has fire and has a POI, reveal it and kill the victim if present
            if tile.fireStatus == 2:
                self.revealPOI(tile)  # Reveal the POI on the tile
                self.killFirefighter(tile)  # Kill any firefighter on the tile

        elif tile.fireStatus == 1:  # If the tile is currently starting to burn
            tile.fireStatus = 2  # Set the fire status to 2 (indicating fire spreading)
            self.killFirefighter(tile)  # Kill any firefighter on the tile

            # If the tile with fire has a POI, reveal it and kill the victim if present
            self.revealPOI(tile)  # Reveal the POI
            self.spreadFire(x, y)  # Spread fire from the current tile

        elif tile.fireStatus == 2:  # If the tile is already on fire
            self.makeExplosion(x, y)  # Trigger an explosion at the coordinates
            self.affectedTiles = []  # Reset the affected tiles list


    def moveDirection(self, x, y, dx, dy):
        # Check if the current position is within the grid boundaries
        if x < 1 or y < 1 or x > self.grid.width-2 or y > self.grid.height-2:
            return

        # Get the current tile at the specified coordinates
        current_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]

        # Check if there is smoke in the current tile
        if current_tile.fireStatus == 1 or current_tile.fireStatus == 0:
            current_tile.fireStatus = 2

            # Kill the firefighter if present on the current tile
            self.killFirefighter(current_tile)
            # If the tile with fire has a POI, reveal it and kill the victim if present
            self.revealPOI(current_tile)
            self.spreadFire(x, y)
            return

        # Check if there is a wall in the direction the agent wants to move
        if (dx == -1 and (current_tile.wall.top != 0 or (current_tile.wall.isDoor == 1 and current_tile.wall.isOpen is False and current_tile.wall.topHealth > 0))) or \
         (dx == 1 and (current_tile.wall.bottom != 0 or (current_tile.wall.isDoor == 3 and current_tile.wall.isOpen is False and current_tile.wall.bottomHealth > 0))) or \
          (dy == -1 and (current_tile.wall.left != 0 or (current_tile.wall.isDoor == 2 and current_tile.wall.isOpen is False and current_tile.wall.leftHealth > 0))) or \
           (dy == 1 and (current_tile.wall.right != 0 or (current_tile.wall.isDoor == 4 and current_tile.wall.isOpen is False and current_tile.wall.rightHealth > 0))):

            # If moving towards it's a wall, increment the damage counter
            if not ((current_tile.wall.top == 2 and dx == -1) or (current_tile.wall.left == 2 and dy == -1) or
              (current_tile.wall.bottom == 2 and dx == 1) or (current_tile.wall.right == 2 and dy == 1)):
                self.damageCounter += 1

            # Move up
            if dx == -1:
                # Check if not at the top boundary
                if x != 1:
                    # Get the tile above the current one
                    other_tile = [obj for obj in self.grid.get_cell_list_contents([(x+dx, y+dy)]) if isinstance(obj, Tile)][0]
                    other_tile.wall.bottomHealth -= 2
                    # Check if the wall health is zero or below
                    if other_tile.wall.bottomHealth <= 0:
                        other_tile.wall.bottomHealth = 0
                        other_tile.wall.bottom = 0

                        # Update the graph for pathfinding
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 1
                    else:
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 3

                    # Mark the other tile as affected
                    self.appendAffectedTile(other_tile,"stand", 0, 0)

                # Reduce the health of the top wall of the current tile
                current_tile.wall.topHealth -= 2

                # Check if the wall health is zero or below
                if current_tile.wall.topHealth <= 0:
                    current_tile.wall.topHealth = 0
                    current_tile.wall.top = 0
                    # Spread fire if wall is destroyed
                    self.spreadFire(x, y)

                    # Update the graph for pathfinding
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 1
                else:
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 3

                # Mark the current tile as affected
                self.appendAffectedTile(current_tile,"stand", 0, 0)

            # Move down
            elif dx == 1:
                # Check if not at the bottom boundary
                if x != self.grid.width - 2:
                    # Get the tile below the current one
                    other_tile = [obj for obj in self.grid.get_cell_list_contents([(x+dx, y+dy)]) if isinstance(obj, Tile)][0]
                    other_tile.wall.topHealth -= 2
                    # Check if the wall health is zero or below
                    if other_tile.wall.topHealth <= 0:
                        other_tile.wall.topHealth = 0
                        other_tile.wall.top = 0
                        # Update the graph for pathfinding
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 1
                    else:
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 3

                    # Mark the other tile as affected
                    self.appendAffectedTile(other_tile, "stand", 0, 0)

                # Reduce the health of the bottom wall of the current tile
                current_tile.wall.bottomHealth -= 2
                # Check if the wall health is zero or below
                if current_tile.wall.bottomHealth <= 0:
                    current_tile.wall.bottomHealth = 0
                    current_tile.wall.bottom = 0
                    # Spread fire if wall is destroyed
                    self.spreadFire(x, y)
                    # Update the graph for pathfinding
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 1
                else:
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 3

                # Mark the other tile as affected
                self.appendAffectedTile(current_tile,"stand", 0, 0)

            # Move left
            elif dy == -1:
                # Check if not at the left boundary
                if y != 1:
                    # Get the tile to the left of the current one
                    other_tile = [obj for obj in self.grid.get_cell_list_contents([(x+dx, y+dy)]) if isinstance(obj, Tile)][0]
                    other_tile.wall.rightHealth -= 2
                    # Check if the wall health is zero or below
                    if other_tile.wall.rightHealth <= 0:
                        other_tile.wall.rightHealth = 0
                        other_tile.wall.right = 0
                        # Update the graph for pathfinding
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 1
                    else:
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 3

                    # Mark the other tile as affected
                    self.appendAffectedTile(other_tile,"stand", 0, 0)

                # Reduce the health of the left wall of the current tile
                current_tile.wall.leftHealth -= 2
                # Check if the wall health is zero or below
                if current_tile.wall.leftHealth <= 0:
                    current_tile.wall.leftHealth = 0
                    current_tile.wall.left = 0
                    # Spread fire if wall is destroyed
                    self.spreadFire(x, y)
                    # Update the graph for pathfinding
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 1
                else:
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 3

                # Mark the other tile as affected
                self.appendAffectedTile(current_tile,"stand", 0, 0)

            # Move right
            elif dy == 1:
                # Check if not at the right boundary
                if y != self.grid.height - 2:
                    # Get the tile to the right of the current one
                    other_tile = [obj for obj in self.grid.get_cell_list_contents([(x+dx, y+dy)]) if isinstance(obj, Tile)][0]
                    other_tile.wall.leftHealth -= 2
                    # Check if the wall health is zero or below
                    if other_tile.wall.leftHealth <= 0:
                        other_tile.wall.leftHealth = 0
                        other_tile.wall.left = 0
                        # Update the graph for pathfinding
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 1
                    else:
                        if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                            self.graph[(x+dx, y+dy)][(x, y)] = 3

                    # Mark the other tile as affected
                    self.appendAffectedTile(other_tile,"stand", 0, 0)

                # Reduce the health of the right wall of the current tile
                current_tile.wall.rightHealth -= 2
                # Check if the wall health is zero or below
                if current_tile.wall.rightHealth <= 0:
                    current_tile.wall.rightHealth = 0
                    current_tile.wall.right = 0
                    # Spread fire if wall is destroyed
                    self.spreadFire(x, y)
                    # Update the graph for pathfinding
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 1
                else:
                    if (x+dx < 6 and x+dx > 0) and (y+dy > 0 and y+dy < 8):
                        self.graph[(x, y)][(x+dx, y+dy)] = 3

                # Mark the other tile as affected
                self.appendAffectedTile(current_tile,"stand", 0, 0)
            return

        # Move to the next position based on the given direction
        new_x = x + dx
        new_y = y + dy

        # Recursive call to continue moving in the specified direction
        self.moveDirection(new_x, new_y, dx, dy)


    def makeExplosion(self, x, y):
        # Retrieve the current tile at position (x, y)
        current_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]

        # Move down from the current position
        self.moveDirection(x, y, 1, 0)

        # Move up from the current position
        self.moveDirection(x, y, -1, 0)

        # Move left from the current position
        self.moveDirection(x, y, 0, -1)

        # Move right from the current position
        self.moveDirection(x, y, 0, 1)

    def spreadFire(self, x, y):
        # Obtain the tile at position (x, y)
        current_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y)]) if isinstance(obj, Tile)][0]

        # If the tile on fire has a Point of Interest (POI), reveal it and kill the victim if present
        self.revealPOI(current_tile)
        self.appendAffectedTile(current_tile,"stand", 0, 0)

        self.affectedTiles = []  # Initialize the list of affected tiles
        # Check if the fireStatus of the current tile is not 0 (not extinguished)
        if current_tile.fireStatus != 0:
            # Check and propagate the fire to adjacent tiles

            # Move down to the adjacent tile below
            if x + 1 <= self.grid.width - 2:  # Ensure it stays within bounds
                bottom_tile = [obj for obj in self.grid.get_cell_list_contents([(x + 1, y)]) if isinstance(obj, Tile)][0]
                # Check if the bottom tile is on fire and if there is no wall or door preventing the fire from spreading
                if bottom_tile.fireStatus == 1 and (current_tile.wall.bottom == 0 or (current_tile.wall.isDoor == 3 and (current_tile.wall.isOpen or current_tile.wall.bottomHealth <= 0))):
                    bottom_tile.fireStatus = 2  # Set the fire status of the bottom tile
                    # Recursively call to propagate the fire from the bottom tile
                    self.spreadFire(x + 1, y)

            # Move up to the adjacent tile above
            if x - 1 >= 1:  # Ensure it stays within bounds
                top_tile = [obj for obj in self.grid.get_cell_list_contents([(x - 1, y)]) if isinstance(obj, Tile)][0]
                # Check if the top tile is on fire and if there is no wall or door preventing the fire from spreading
                if top_tile.fireStatus == 1 and (current_tile.wall.top == 0 or (current_tile.wall.isDoor == 1 and (current_tile.wall.isOpen or current_tile.wall.topHealth <= 0))):
                    top_tile.fireStatus = 2  # Set the fire status of the top tile
                    # Recursively call to propagate the fire from the top tile
                    self.spreadFire(x - 1, y)

            # Move left to the adjacent tile on the left
            if y - 1 >= 1:  # Ensure it stays within bounds
                left_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y - 1)]) if isinstance(obj, Tile)][0]
                # Check if the left tile is on fire and if there is no wall or door preventing the fire from spreading
                if left_tile.fireStatus == 1 and (current_tile.wall.left == 0 or (current_tile.wall.isDoor == 2 and (current_tile.wall.isOpen or current_tile.wall.leftHealth <= 0))):
                    left_tile.fireStatus = 2  # Set the fire status of the left tile
                    # Recursively call to propagate the fire from the left tile
                    self.spreadFire(x, y - 1)

            # Move right to the adjacent tile on the right
            if y + 1 <= self.grid.height - 2:  # Ensure it stays within bounds
                right_tile = [obj for obj in self.grid.get_cell_list_contents([(x, y + 1)]) if isinstance(obj, Tile)][0]

                # Check if the right tile is on fire and if there is no wall or door preventing the fire from spreading
                if right_tile.fireStatus == 1 and (current_tile.wall.right == 0 or (current_tile.wall.isDoor == 4 and (current_tile.wall.isOpen or current_tile.wall.rightHealth <= 0))):
                    right_tile.fireStatus = 2  # Set the fire status of the right tile
                    # Recursively call to propagate the fire from the right tile
                    self.spreadFire(x, y + 1)

    def generateGraph(self, matrix):
        # Get the number of rows and columns in the matrix
        rows = len(matrix)
        cols = len(matrix[0])
        graph = {}  # Initialize an empty graph

        # Iterate through each cell in the matrix using 1-based indexing
        for x in range(1, rows + 1):  # 1-based index
            for y in range(1, cols + 1):
                node = (x, y)  # Create a node for the current position
                graph[node] = {}  # Initialize the adjacency list for the node

                # Assign variables to each one of the 4 numbers from the matrix
                WXYZ = matrix[x-1][y-1]  # Keep the original string representing the connections
                W, X, Y, Z = int(WXYZ[0]), int(WXYZ[1]), int(WXYZ[2]), int(WXYZ[3])  # Parse the connection values

                # Check the UP direction (connect to (x-1, y))
                if W == 0 and x > 1:  # If no wall, connect with cost 1
                    graph[node][(x-1, y)] = 1
                elif W == 1 and x > 1:  # If wall, connect with cost 5
                    graph[node][(x-1, y)] = 5

                # Check the LEFT direction (connect to (x, y-1))
                if X == 0 and y > 1:  # If no wall, connect with cost 1
                    graph[node][(x, y-1)] = 1
                elif X == 1 and y > 1:  # If wall, connect with cost 5
                    graph[node][(x, y-1)] = 5

                # Check the DOWN direction (connect to (x+1, y))
                if Y == 0 and x < rows:  # If no wall, connect with cost 1
                    graph[node][(x+1, y)] = 1
                elif Y == 1 and x < rows:  # If wall, connect with cost 5
                    graph[node][(x+1, y)] = 5

                # Check the RIGHT direction (connect to (x, y+1))
                if Z == 0 and y < cols:  # If no wall, connect with cost 1
                    graph[node][(x, y+1)] = 1
                elif Z == 1 and y < cols:  # If wall, connect with cost 5
                    graph[node][(x, y+1)] = 5

        return graph  # Return the constructed graph

    def addDoorArches(self, graph, door_arches, cost):
        # Iterate through each door arch defined in door_arches
        for arch in door_arches:
            x1, y1, x2, y2 = arch  # Unpack the coordinates of the door arch
            node1 = (x1, y1)  # Create the first node
            node2 = (x2, y2)  # Create the second node

            # Add the connection with the specified cost if node1 exists in the graph
            if node1 in graph:
                graph[node1][node2] = cost
            # Add the connection with the specified cost if node2 exists in the graph
            if node2 in graph:
                graph[node2][node1] = cost

        return graph  # Return the updated graph with door arches


    def createInitialDictionary(self):
        # Initialize an empty dictionary to store initial tile data
        self.initialDictionary = {}

        # Iterate through the grid dimensions, excluding the outer edges
        for i in range(1, self.grid.width-1):
            for j in range(1, self.grid.height-1):
                # Retrieve the tile at the current position (i, j)
                tile = [obj for obj in self.grid.get_cell_list_contents([(i, j)]) if isinstance(obj, Tile)][0]
                firefightersIDs = []  # Initialize a list to store the unique IDs of firefighters

                # Iterate through the firefighters assigned to the tile
                for firefighter in tile.hasFireFighter:
                    # Append each firefighter's unique ID to the list
                    firefightersIDs.append(firefighter.unique_id)

                self.initialDictionary[(i, j)] = {
                    "top": tile.wall.top,  # Top wall status
                    "left": tile.wall.left,  # Left wall status
                    "bottom": tile.wall.bottom,  # Bottom wall status
                    "right": tile.wall.right,  # Right wall status
                    "isOpen": tile.wall.isOpen,  # Door open/closed status
                    "topHealth": tile.wall.topHealth,  # Top wall health
                    "leftHealth": tile.wall.leftHealth,  # Left wall health
                    "bottomHealth": tile.wall.bottomHealth,  # Bottom wall health
                    "rightHealth": tile.wall.rightHealth,  # Right wall health
                    "fireStatus": tile.fireStatus,  # Status of fire on the tile
                    "hasPoi": tile.hasPOI,  # Boolean indicating if the tile has a Point of Interest (POI)
                    "numberVictims": tile.numberOfVictims,  # Number of victims present on the tile
                    "firefighters": firefightersIDs  # List of IDs of firefighters present on the tile
                }

# Define constants for the grid dimensions and number of firefighters
WIDTH = 10
HEIGHT = 8
FIREFIGHTERS = 6
MAX_ITERATIONS = 50
iteration = 0

def process_file(filename):
    # Open the specified file in read mode
    with open(filename, 'r') as file:
        # Read all lines from the file
        lines = file.readlines()

    # Initialize lists to store different elements of the simulation
    walls = []
    POIS = []  # Points of Interest
    fires = []
    doors = []
    entryPoints = []

    # Read the first 6 lines to build the walls structure
    for i in range(6):
        row = []
        binary = lines[i].strip().split()  # Split the line into binary values
        for num in binary:
            # Convert the string to a list of integers representing wall properties
            wall = [int(num[0]), int(num[1]), int(num[2]), int(num[3])]
            row.append(wall)  # Append the wall data to the row
        walls.append(row)  # Append the row to the walls list

    # Read the remaining lines for POIs, fires, doors, and entry points
    rest = [line.strip().split() for line in lines[6:]]

    # Parse Points of Interest (POIs)
    for item in rest:
        if len(item) == 3 and item[2] in ['v', 'f']:  # Check for valid POI format
            POIS.append([int(item[0]), int(item[1]), item[2]])  # Append POI data
        elif len(item) == 2:
            break  # Break if the format doesn't match

    # Parse fire locations
    for item in rest:
        if len(item) == 2:
            fires.append([int(item[0]), int(item[1])])  # Append fire coordinates
        elif len(item) == 4:
            break  # Break if the format doesn't match

    # Parse door locations
    for item in rest:
        if len(item) == 4:
            doors.append([int(x) for x in item])  # Append door data
        elif len(item) == 2 and [int(item[0]), int(item[1])] not in fires:
            break  # Break if the format doesn't match

    # Parse entry points, reversing the order to maintain original sequence
    for item in rest[::-1]:
        if len(item) == 2:
            entryPoints.append((int(item[0]), int(item[1])))  # Append entry point coordinates
        else:
            break  # Break if the format doesn't match
    entryPoints.reverse()  # Reverse to restore the correct order

    return walls, POIS, fires, doors, entryPoints  # Return the parsed data

# Set the filename for the input data
filename = "input.txt"
# Process the file to get walls, POIs, fires, doors, and entry points
walls, POIS, fires, doors, entryPoints = process_file(filename)

# Initialize the Fire Rescue Model with the parsed data
model = FireRescueModel(FIREFIGHTERS, HEIGHT, WIDTH, entryPoints, walls, doors, fires, POIS)

# Set the initial dictionary
model.createInitialDictionary()

# Run the simulation while the model is active
while model.running:
    model.step()  # Perform a step in the model's simulation

# Function to parse action details from input data
def parse_actions(x):
    return {
        "x": x[0][0],  # x-coordinate of the tile
        "y": x[0][1],  # y-coordinate of the tile
        "top": x[1],  # Top wall status
        "left": x[2],  # Left wall status
        "bottom": x[3],  # Bottom wall status
        "right": x[4],  # Right wall status
        "isOpen": x[5],  # Door open/closed status
        "topHealth": x[6],  # Top wall health
        "leftHealth": x[7],  # Left wall health
        "bottomHealth": x[8],  # Bottom wall health
        "rightHealth": x[9],  # Right wall health
        "fireStatus": x[10],  # Fire status on the tile
        "hasPOI": x[11],  # Whether the tile has a Point of Interest (POI)
        "numberOfVictims": x[12],  # Number of victims on the tile
        "firefightersIDs": x[13],  # List of firefighters present on the tile
        "actions": x[14],  # Actions performed on the tile
        "dx": x[15],  # Change in x-coordinate
        "dy": x[16],  # Change in y-coordinate
        "damageCounter": x[17],  # Counter for damage on the tile
        "poi": x[18],  # POI on the tile
        "savedVictims": x[19],  # Number of saved victims
        "deadVictims": x[20]  # Number of dead victims
    }

# Dictionary to store pending actions
pending_actions = {}

# Loop through each item in the model's dictionary list
for (k, v) in enumerate(model.dictionaryList):

    n1_acc = []  # Accumulator for storing agent step data
    # Loop through each bot ID and its associated data
    for xx, xy in v.items():
        n2_acc = []  # Accumulator for affected tile data
        # Loop through each model step and its data
        for yy, y in enumerate(xy):
            n2_acc.append({
                "model_step_id": yy,  # ID of the model step
                "affected_tiles_data": parse_actions(y)  # Parse the affected tile data
            })
        n1 = {
            "bot_id": xx,  # ID of the bot
            "agent_step_data": n2_acc  # Data of agent steps
        }
        n1_acc.append(n1)  # Append the agent step data to the list

    # Store the accumulated agent data for the current run
    pending_actions[f"run_{k}"] = n1_acc

# Serialize the pending actions to JSON format with indentation
parsedJSON = json.dumps(pending_actions, indent=4)

# TC2008B Modelación de Sistemas Multiagentes con gráficas computacionales
# Python server to interact with Unity via POST
# Sergio Ruiz-Loza, Ph.D. March 2021

from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import json

class Server(BaseHTTPRequestHandler):
    request_count = 0

    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()

    def do_GET(self):
        self._set_response()
        self.wfile.write("GET request for {}".format(self.path).encode('utf-8'))

    # Handle POST requests
    def do_POST(self):
        Server.request_count += 1  # Increment request counter
        logging.info(f"Received POST request #{Server.request_count}")  # Log the request
        tiles = model.initialDictionary  # Retrieve initial dictionary of tiles
        # Serialize the tile data into a dictionary with coordinates as keys
        tiles_serialized = {f"{k[0]},{k[1]}": v for k, v in tiles.items()}

        # If it's the first request, send the tile data
        if Server.request_count == 1:
            self._set_response()  # Set response headers
            self.wfile.write(json.dumps(tiles_serialized).encode('utf-8'))  # Send the serialized tile data
            logging.info("Sent tiles")  # Log the action
        else:
            self._set_response()  # Set response headers
            self.wfile.write(parsedJSON.encode('utf-8'))  # Send the parsed actions JSON
            logging.info("Sent moves")  # Log the action
            Server.request_count = 0  # Reset request counter


def run(server_class=HTTPServer, handler_class=Server, port=8585):
    logging.basicConfig(level=logging.INFO)
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info("Starting httpd...\n") # HTTPD is HTTP Daemon!

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:   # CTRL+C stops the server
        pass
    httpd.server_close()
    logging.info("Stopping httpd...\n")

if __name__ == '__main__':
    from sys import argv

    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()

deadVictimsLoses = 0
wins = 0
demolishedLoses = 0
damageCounter = []
savedVictims = []
deadVictims = []
results = []

# Simulación de 10 ejecuciones
for i in range(50):
    model1 = FireRescueModel(FIREFIGHTERS, HEIGHT, WIDTH, entryPoints, walls, doors, fires, POIS)
    while model1.running:
        model1.step()

    # Determinar el resultado
    if model1.win == 1:
        outcome = "Win"
        wins += 1
    elif model1.demolishedLose == 1:
        outcome = "Lose - Demolished"
        demolishedLoses += 1
    elif model1.deadVictimLose == 1:
        outcome = "Lose - Dead Victims"
        deadVictimsLoses += 1

    # Almacenar los resultados de esta ejecución
    damageCounter.append(model1.damageCounter)
    savedVictims.append(model1.savedVictims)
    deadVictims.append(model1.deadVictims)
    results.append({
        "Run": i + 1,
        "Damage Counter": model1.damageCounter,
        "Saved Victims": model1.savedVictims,
        "Dead Victims": model1.deadVictims,
        "Outcome": outcome
    })

# Crear un DataFrame de pandas
df = pd.DataFrame(results)

# Mostrar el DataFrame en forma de tabla
print(df)

